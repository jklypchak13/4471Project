Proposed design regarding Physics in Trojan Horse game. This is only an initial suggestion and should probably be improved on or needs more detail. This is not psuedocode, and all the class/variable names are just placeholder examples for the sake of discussion.

Two game object types:
__________________________________________________
1. GameObject class:
	has x and y position values
	reference to bitmap image
	
2. Physics class extends GameObject:
	adds x and y velocity values
__________________________________________________


GameState class stores global references to:
	player object (Physics object)
	list of enemy objects (each one is physics object)
	list of platform objects (these are just GameObjects, no physics)
	ground object? (ground may be its own object or made of one or more platform objects)
	end? (if the game scrolls infinitely collision detection with level end is not needed)
	screen edges? (collision with left and right edge to keep player on screen)



Four classes that interact with the physics:
__________________________________________________
1. CollisionManager class:
	checks two types of collisions:
		platforms: 
			all these collisions should be similar and could be handled by one method like: physCollision(physObj, platformObj)
			checks player collision against ground/platforms
			checks player with edges of screen
			checks enemy collisions against ground/platforms
			for player and each enemy: updated velocity and position values accordingly
		non-physics
			each of these collisions is handled by it's own method
			player with enemy->game fail or enemy dies
			player with end->game win
	collision manager updates position and velociyt values on physics objects

2. InputManager class:
	takes keyboard input from player
	adjust pos and vel on player object

3. TimeUpdate class:
	update the positions of everything on screen according to their velocities
	update velocities according to the value/implementation of gravity
	can be based on the frequency of the for loop, or the system clock. can also scale speed of time up or down. scale to zero to implement pause etc...

4. DrawManager class:
	draws everything on screen according to their GameObject inherited xy positions
__________________________________________________



So in every game loop you have something like:

while gameIsRunning:
	collisionManager.run()
	inputManager.run()
	timeUpdate.run()
	drawManager.run()
